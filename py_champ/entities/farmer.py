r"""
The code is developed by Chung-Yi Lin at Virginia Tech, in April 2023.
Email: chungyi@vt.edu
Last modified on Sep 6, 2023
"""
import numpy as np
import mesa
from scipy.stats import truncnorm
from .opt_model import OptModel
from ..util import Box

class Farmer(mesa.Agent):
    """
       A Farmer agent for the MESA model.
    
       Attributes
       ----------
       agt_type : str
           Type of the agent, set to "Farmer".
       farmer_id : str or int
           Unique identifier for the agent.
       crop_options : dict
           Available crop options for the farmer.
       tech_options : dict
           Available technology options for the farmer.
       dm_args : dict
           Decision-making arguments specific to the agent.
       farmer_ids_in_network : list
           List of agent IDs in the network.
       water_rights : dict
           Information about the agent's water rights.
       aquifers : dict
           A dictionary containing aquifer objects. The key is the aquifer ID.
       fields : dict
           A dictionary containing the fields the farmer owns.
       Fields : Box
           Same as `fields` but with dotted access.
       num_fields : int
           Number of fields owned by the farmer.
       wells : dict
           A dictionary containing the wells the farmer owns.
       Wells : Box
           Same as `wells` but with dotted access.
       num_wells : int
           Number of wells owned by the farmer.
       finance : object
           Financial object for the agent.
       state : str or None
           Current state of the agent in the CONSUMAT model.
       satisfaction : float or None
           Current satisfaction level of the agent.
       expected_sa : float or None
           Expected satisfaction from optimization.
       uncertainty : float or None
           Current uncertainty level of the agent.
       irr_vol : float or None
           Irrigation volume in m-ha.
       profit : float or None
           Profit generated by the agent in 1e4$.
       yield_rate : float or None
           Yield rate of the agent's crops.
       scaled_profit : float or None
           Scaled profit value.
       scaled_yield_rate : float or None
           Scaled yield rate value.
       needs : dict
           Dictionary of the agent's needs.
       farmers_in_network : dict
           Dictionary of agents in the network.
       selected_farmer_id_in_network : str or None
           ID of the selected agent in the network after social comparison.
       t : int
           Current time step.
       current_year : int
           Current simulation year.
       percieved_risks : float or None
           Perceived risks by the agent.
       perceived_prec_aw : float or None
           Perceived avalible precipitation.
       dm_sols : dict
           Decision-making solutions, mimicking opt_model's output.
    
       """

    def __init__(self, farmer_id, mesa_model, config, agt_attrs, 
                 fields, wells, finance, aquifers,
                 ini_year,
                 crop_options, tech_options, **kwargs):
        """
        Initialize a Farmer agent.

        Parameters
        ----------
        farmer_id : str or int
            Unique identifier for the agent.
        mesa_model : object
            Reference to the overarching MESA model instance.
        config : dict or DotMap
            General configuration information for the model.
        agt_attrs : dict
            Agent-specific attributes for simulation.
        fields : dict
            A dictionary contains the fields the farmer owns.
        wells : dict
            A dictionary contains the wells the farmer owns.
        finance : object
            Financial object for the agent.
        aquifers : dict
            A dictionary contain aquifer objects.
        ini_year : int
            Initial simulation year.
        crop_options : dict
            Available crop options for the farmer.
        tech_options : dict
            Available technology options for the farmer.
        kwargs : dict, optional
            Additional optional arguments.

        Notes
        -----
        The `kwargs` could contain any additional attributes that you want to
        add to the Farmer agent. Available keywords include:
        - fix_state : str
            "Imitation", "Social comparison", "Repetition", "Deliberation", 
            and "FixCrop".  
        - rngen : object
            Numpy random generator.
        """
        # MESA required attributes => (unique_id, model)
        super().__init__(farmer_id, mesa_model)
        self.agt_type = "Farmer"

        # Load other kwargs
        for k, v in kwargs.items():
            setattr(self, k, v)
            
        self.fix_state = kwargs.get("fix_state")
        #========
        self.farmer_id = farmer_id
        self.crop_options = crop_options
        self.tech_options = tech_options

        # Load agt_attrs
        self.dm_args = agt_attrs["decision_making"]
        self.farmer_ids_in_network = agt_attrs["farmer_ids_in_network"]
        self.water_rights = agt_attrs["water_rights"]

        # Load config
        self.load_config(config)
        # Calculate consumat threshold (has to be after load_config) 
        self.process_consumat_thresholds()

        # Assign agt's assets
        self.aquifers = aquifers
        self.fields = fields
        self.Fields = Box(fields) # same as self.fields but with dotted access
        self.num_fields = len(fields)
        self.wells = wells
        self.Wells = Box(wells) # same as self.fields but with dotted access
        self.num_wells = len(wells)
        self.finance = finance

        # Initialize CONSUMAT
        self.state = None
        self.satisfaction = None
        self.expected_sa = None     # From optimization
        self.uncertainty = None
        self.irr_vol = None         # m-ha
        self.profit = None
        self.yield_rate = None
        
        self.scaled_profit = None
        self.scaled_yield_rate = None
        
        self.needs = {}
        self.farmers_in_network = {}   # This will be dynamically updated in a simulation
        self.selected_farmer_id_in_network = None # This will be populated after social comparison
        
        # Some other attributes
        self.t = 0
        self.current_year = ini_year
        self.percieved_risks = None
        self.perceived_prec_aw = None
        
        # Initialize dm_sol (mimicing opt_model's output)
        dm_sols = {}
        for fi, field in self.fields.items():
            dm_sols[fi] = {}
            dm_sols[fi]["i_crop"] = field.i_crop
            dm_sols[fi]["pre_i_crop"] = field.pre_i_crop
            dm_sols[fi]["i_te"] = field.te
            dm_sols[fi]["pre_i_te"] = field.pre_te
        # Run the optimization to solve irr depth with every other variables
        # fixed.
        self.dm_sols = self.make_dm(None, dm_sols=dm_sols, init=True)
        self.dm_sols_neighbor = None 
        # Run the simulation to calculate satisfication and uncertainty
        self.run_simulation() # aquifers

    def load_config(self, config):
        """
        Load config.

        Parameters
        ----------
        config : dict
            General configuration of the model.

        Returns
        -------
        None.

        """
        config_consumat = config["consumat"]
        if self.dm_args["alphas"] is None:
            self.dm_args["alphas"] = config_consumat["alpha"]
        self.dm_args["scale"] = config_consumat["scale"]

        self.sa_thre_par = config_consumat["satisfaction_threshold"]
        self.un_thre_par = config_consumat["uncertainty_threshold"]
        self.n_s = config["field"]["area_split"]

        self.config_gurobi = config["gurobi"]
        self.config = config  # for opt only

    def process_percieved_risks(self, par_perceived_risk):
        """
        Process and compute the perceived risks for each field and crop option.
    
        Parameters
        ----------
        par_perceived_risk : float
            Parental perceived risk value used for computing the agent's perceived risks.
    
        Attributes Modified
        -------------------
        percieved_risks : dict
            Updated dictionary containing the perceived risks for each crop option.
    
        Notes
        -----
        This method updates the `percieved_risks` attribute of the Farmer agent based
        on the `par_perceived_risk` and other field-specific parameters. The perceived
        risks are computed using the truncated normal distribution.
    
        The method assumes that the `fields` attribute and `crop_options` are already
        initialized and populated.
        """
        for fi, field in self.fields.items():
            #Compute perceived_prec_aw based on perceived_risk
            truncated_normal_pars = field.truncated_normal_pars
            percieved_risks = {
                crop: 0 if crop=="fallow" else \
                    round(
                        truncnorm.ppf(
                            q=par_perceived_risk,
                            a=truncated_normal_pars[crop][0],
                            b=truncated_normal_pars[crop][1],
                            loc=truncated_normal_pars[crop][2],
                            scale=truncated_normal_pars[crop][3]),
                        4
                    ) for crop in self.crop_options}
        self.percieved_risks = percieved_risks
    
    def process_consumat_thresholds(self):
        """
        Process and set the consumat thresholds for the agent.
    
        This method checks if the threshold parameters (`sa_thre_par` and `un_thre_par`) 
        are tuples. If they are, it calculates a random value from a truncated normal 
        distribution using the given parameters. If not, it directly assigns the parameter 
        value to the threshold.
    
        Attributes
        ----------
        sa_thre : float
            The threshold value for `sa` (satisfaction). If `sa_thre_par` is a tuple, 
            `sa_thre` is derived from a truncated normal distribution. Otherwise, it's 
            directly set to `sa_thre_par`.
        un_thre : float
            The threshold value for `un` (uncertainty). If `un_thre_par` is a tuple, 
            `un_thre` is derived from a truncated normal distribution. Otherwise, it's 
            directly set to `un_thre_par`.
    
        Returns
        -------
        None
    
        """
        sa_thre_par = self.sa_thre_par
        un_thre_par = self.un_thre_par
        
        if isinstance(sa_thre_par, tuple):
            loc = sa_thre_par[0]; scale = sa_thre_par[1]
            a, b = (0 - loc) / scale, (1 - loc) / scale
            self.sa_thre = truncnorm.rvs(a, b, loc=loc, scale=scale, size=1, random_state=self.rngen)[0]
        else:
            self.sa_thre = sa_thre_par
        
        if isinstance(un_thre_par, tuple):
            loc = un_thre_par[0]; scale = un_thre_par[1]
            a, b = (0 - loc) / scale, (1 - loc) / scale
            self.un_thre = truncnorm.rvs(a, b, loc=loc, scale=scale, size=1, random_state=self.rngen)[0]
        else:
            self.un_thre = un_thre_par
            
    
    def update_perceived_prec_aw(self, par_forecast_trust, year):
        """
        Update the agent's perceived precipitation awareness based on forecast trust and year.
    
        Parameters
        ----------
        par_forecast_trust : float
            Parental forecast trust value used for blending the agent's original 
            perceived precipitation awareness with the perfect forecast.
        year : int
            The year for which the perceived precipitation awareness is to be updated. 
            Should be one step ahead of the agent's current year.
    
        Attributes Modified
        -------------------
        perceived_prec_aw : dict
            Updated dictionary containing the perceived available precipitation for each field.
    
        Notes
        -----
        This method updates the `perceived_prec_aw` attribute of the Farmer agent based
        on the `par_forecast_trust` and other field-specific parameters. The perceived
        available precipitation is a blend of the agent's original perception and the 
        perfect forecast.
    
        The method assumes that the `fields` and `percieved_risks` attributes are already
        initialized and populated.
        """
        # year != self.current_year (should be one step ahead)
        # Blend agt's original perceived prec_aw with the perfect prec_aw
        # forecast before the optimization.
        fotr = par_forecast_trust
        perceived_prec_aw = {}
        for fi, field in self.fields.items():
            percieved_risks = self.percieved_risks
            prec_aw = field.prec_aw_step[year]
            perceived_prec_aw_f = {
                crop: round(percieved_risks[crop]*(1-fotr) + prec_aw[crop]*fotr, 4) \
                    for crop in percieved_risks
                }
            perceived_prec_aw[fi] = perceived_prec_aw_f
        self.perceived_prec_aw = perceived_prec_aw

    def step(self):
        """
        Simulate a single timestep.
        """
        self.t += 1
        self.current_year += 1
        
        ### Optimization
        # Make decisions based on CONSUMAT theory
        state = self.state
        if state == "Imitation":
            self.make_dm_imitation()
        elif state == "Social comparison":
            self.make_dm_social_comparison()
        elif state == "Repetition":
            self.make_dm_repetition()
        elif state == "Deliberation":
            self.make_dm_deliberation()
        
        # Internal experiment
        elif state == 'FixCrop':
            self.make_dm_deliberation()

        # Retrieve opt info
        # try:
        #     dm_sols = self.dm_sols
        #     self.gp_status = dm_sols['gp_status']
        #     self.gp_MIPGap = dm_sols['gp_MIPGap']
        #     self.gp_report = dm_sols['gp_report']
        # except:
        #     pass
        ### Simulation
        # Note prec_aw_dict have to be updated externally first.
        self.run_simulation()

        return self

    def run_simulation(self):
        """
        Run the simulation for the Farmer agent for a single time step.
    
        Attributes Modified
        -------------------
        irr_vol : float
            Total irrigation volume across all fields.
        profit : float
            Profit generated by the agent.
        yield_rate : float
            Yield rate of the agent's crops.
        scaled_profit : float
            Scaled profit value.
        scaled_yield_rate : float
            Scaled yield rate value.
        satisfaction : float
            Current satisfaction level of the agent.
        expected_sa : float
            Expected satisfaction from optimization.
        uncertainty : float
            Current uncertainty level of the agent.
        state : str
            Updated CONSUMAT state of the agent.
    
        Notes
        -----
        This method performs several key steps:
        1. Simulates the fields based on the decision-making solutions (`dm_sols`).
        2. Simulates the wells based on the decision-making solutions.
        3. Updates the financial status of the agent.
        4. Calculates key metrics like profit, yield rate, satisfaction, and uncertainty.
        5. Updates the CONSUMAT state of the agent based on the calculated metrics.
    
        The method assumes that all required attributes like `fields`, `wells`, `finance`,
        `dm_sols`, and `dm_args` are already initialized and populated.
        """
        aquifers = self.aquifers
        fields = self.fields
        wells = self.wells

        # Optimization's output
        dm_sols = self.dm_sols

        # agt dc settings
        dm_args = self.dm_args

        # Simulate fields
        for fi, field in fields.items():
            irr_depth = dm_sols[fi]["irr_depth"][:,:,[0]]
            i_crop = dm_sols[fi]["i_crop"]
            i_te = dm_sols[fi]["i_te"]
            field.step(
                irr_depth=irr_depth, i_crop=i_crop, i_te=i_te, 
                prec_aw=field.prec_aw_step[self.current_year] # Retrieve prec data
                )
            dm_sols[fi]["i_crop"] = field.i_crop # Since field.step might update this.
            i_rainfed = dm_sols[fi]['i_rainfed']
            for si in range(i_rainfed.shape[0]):
                if sum(sum(i_rainfed[si,:,:])) > 0.5:
                    i_rainfed[si,:,:] = field.i_crop[si,:,:]                    

        # Simulate wells (energy consumption)
        allo_r = dm_sols['allo_r']         # Well allocation ratio from optimization
        allo_r_w = dm_sols["allo_r_w"]     # Well allocation ratio from optimization
        field_ids = dm_sols["field_ids"]
        well_ids = dm_sols["well_ids"]
        self.irr_vol = sum([field.irr_vol_per_field for _, field in fields.items()])

        for k, wid in enumerate(well_ids):
            well = wells[wid]
            # Select the first year over the planning horizon from opt
            withdrawal = self.irr_vol * allo_r_w[k, 0]
            pumping_rate = sum([fields[fid].pumping_rate * allo_r[f,k,0] for f, fid in enumerate(field_ids)])
            l_pr = sum([fields[fid].l_pr * allo_r[f,k,0] for f, fid in enumerate(field_ids)])
            dwl = aquifers[well.aquifer_id].dwl * dm_args["weight_dwl"]
            well.step(withdrawal=withdrawal, dwl=dwl, pumping_rate=pumping_rate, l_pr=l_pr)

        # Calulate profit and pumping cost
        self.finance.step(fields=fields, wells=wells)

        # Collect variables for evaluation metrices
        self.profit = self.finance.profit
        yield_rate = sum([field.yield_rate_per_field for _, field in fields.items()])/len(fields)
        self.yield_rate = yield_rate

        # Calculate satisfaction and uncertainty
        needs = self.needs
        scales = dm_args["scale"]
        self.scaled_profit = self.profit/scales["profit"]
        self.scaled_yield_rate = self.yield_rate/scales["yield_rate"]

        def func(x, alpha=1):
            return 1-np.exp(-alpha * x)
        alphas = dm_args["alphas"]
        for var, alpha in alphas.items():
            if alpha is None:
                continue
            needs[var] = func(eval(f"self.scaled_{var}"), alpha=alpha)

        eval_metric = dm_args["eval_metric"]
        satisfaction = needs[eval_metric]
        expected_sa = dm_sols["Sa"][eval_metric]
        
        # We define uncertainty to be the difference between expected_sa at the
        # previous time and satisfication this year.
        expected_sa_t_1 = self.expected_sa
        if expected_sa_t_1 is None:
            uncertainty = abs(expected_sa - satisfaction)
        else:
            uncertainty = abs(expected_sa_t_1 - satisfaction)

        # Update CONSUMAT state
        self.satisfaction = satisfaction
        self.expected_sa = expected_sa
        self.uncertainty = uncertainty
        sa_thre = self.sa_thre
        un_thre = self.un_thre
        
        if satisfaction >= sa_thre and uncertainty >= un_thre:
            self.state = "Imitation"
        elif satisfaction < sa_thre and uncertainty >= un_thre:
            self.state = "Social comparison"
        elif satisfaction >= sa_thre and uncertainty < un_thre:
            self.state = "Repetition"
        elif satisfaction < sa_thre and uncertainty < un_thre:
            self.state = "Deliberation"
        
        if self.fix_state is not None:
            self.state = self.fix_state
        
    def make_dm(self, state, dm_sols, dm_sols_neighbor=None, init=False):
        """
        Create and solve an optimization model for decision-making.
    
        Parameters
        ----------
        state : str or None
            Current CONSUMAT state of the agent. Determines the type of optimization to run.
        dm_sols : dict
            Previous decision-making solutions, used as input for the optimization model.
        init : bool, optional
            Flag to indicate if this is the initial setup. Default is False.
    
        Returns
        -------
        dm_sols : dict
            Updated decision-making solutions after solving the optimization model.
    
        Notes
        -----
        This method performs several key steps:
        1. Initializes the optimization model with various settings.
        2. Sets up constraints for fields based on the agent's state.
        3. Sets up constraints for wells.
        4. Sets up constraints for water rights.
        5. Solves the optimization model.
        6. Returns the updated decision-making solutions.
    
        The method assumes that all required attributes like `fields`, `wells`, `aquifers`,
        `dm_args`, and `water_rights` are already initialized and populated.
    
        The `state` parameter can take values like "FixCrop", "Deliberation", etc., which
        determine the type of optimization to run.
        """
        aquifers = self.aquifers
        dm_args = self.dm_args
        fields = self.fields
        wells = self.wells
        
        dm = OptModel(name=self.farmer_id,
                      LogToConsole=self.config_gurobi.get("LogToConsole"))
        dm.setup_ini_model(
            config=self.config,
            horizon=dm_args["horizon"],
            eval_metric=dm_args["eval_metric"],
            crop_options=self.crop_options,
            tech_options=self.tech_options,
            approx_horizon=dm_args["approx_horizon"]
            )

        perceived_prec_aw = self.perceived_prec_aw
        for fi, field in fields.items():
            block_w_interval_for_corn = field.block_w_interval_for_corn
            dm_sols_fi = dm_sols[fi]
            if init:
                # only optimize irrigation depth with others given
                dm.setup_constr_field(
                    field_id=fi,
                    prec_aw=field.prec_aw_step[self.current_year],
                    pre_i_crop=dm_sols_fi['pre_i_crop'],   # potential bug
                    pre_i_te=dm_sols_fi['pre_i_te'],
                    field_type=field.field_type,
                    i_crop=dm_sols_fi['i_crop'],
                    i_rainfed=None,
                    i_te=dm_sols_fi['i_te'],
                    block_w_interval_for_corn=block_w_interval_for_corn
                    )
            elif state == "FixCrop":
                dm.setup_constr_field(
                    field_id=fi,
                    prec_aw=perceived_prec_aw[fi],
                    pre_i_crop=dm_sols_fi['pre_i_crop'],
                    pre_i_te=dm_sols_fi['pre_i_te'],
                    field_type=field.field_type,
                    i_crop=dm_sols_fi['i_crop'],
                    i_rainfed=None,
                    i_te=dm_sols_fi['i_te'],
                    block_w_interval_for_corn=block_w_interval_for_corn
                    )
            elif state == "Deliberation":
                # optimize irrigation depth, crop choice, tech choice
                dm.setup_constr_field(
                    field_id=fi,
                    prec_aw=perceived_prec_aw[fi],
                    pre_i_crop=dm_sols_fi['pre_i_crop'],
                    pre_i_te=dm_sols_fi['pre_i_te'],
                    field_type=field.field_type,
                    i_crop=None,
                    i_rainfed=None,
                    i_te=None,
                    block_w_interval_for_corn=block_w_interval_for_corn
                    )
            elif state == "Repetition":
                # only optimize irrigation depth
                dm.setup_constr_field(
                    field_id=fi,
                    prec_aw=perceived_prec_aw[fi],
                    pre_i_crop=dm_sols_fi['pre_i_crop'],
                    pre_i_te=dm_sols_fi['pre_i_te'],
                    field_type=field.field_type,
                    i_crop=dm_sols_fi['i_crop'],
                    i_rainfed=dm_sols_fi['i_rainfed'],
                    i_te=dm_sols_fi['i_te'],
                    block_w_interval_for_corn=block_w_interval_for_corn
                    )
            else: # social comparason & imitation
                #print(state)
                dm.setup_constr_field(
                    field_id=fi,
                    prec_aw=perceived_prec_aw[fi],
                    pre_i_crop=dm_sols_fi['pre_i_crop'],
                    pre_i_te=dm_sols_fi['pre_i_te'],
                    field_type=field.field_type,
                    i_crop=dm_sols_neighbor[fi]['i_crop'],
                    i_rainfed=dm_sols_neighbor[fi]['i_rainfed'],
                    i_te=dm_sols_neighbor[fi]['i_te'],
                    block_w_interval_for_corn=block_w_interval_for_corn
                    )

        for wi, well in wells.items():
            aquifer_id = well.aquifer_id
            proj_dwl = np.mean(aquifers[aquifer_id].dwl_list[-dm_args['n_dwl']:])
            dm.setup_constr_well(
                well_id=wi, dwl=proj_dwl, st=well.st,
                l_wt=well.l_wt, r=well.r, k=well.k,
                sy=well.sy, eff_pump=well.eff_pump,
                eff_well=well.eff_well,
                pumping_capacity=well.pumping_capacity
                )


        if init: # Inputted
            water_rights = self.water_rights
        else: # Use agent's own water rights (for social comparison and imitation)
            water_rights = self.dm_sols["water_rights"]

        for wr_id, v in self.water_rights.items():
            if v["status"]: # Check whether the wr is activated
                # Extract the water right setting from the previous opt run,
                # which we record the remaining water right fromt the previous
                # year. If the wr is newly activate in a simulation, then we
                # use the input to setup the wr.
                wr_args = water_rights.get(wr_id)
                if wr_args is None: # when first time introduce the water rights
                    dm.setup_constr_wr(
                        water_right_id=wr_id, wr=v["wr"],
                        field_id_list=v['field_id_list'],
                        time_window=v['time_window'],
                        remaining_tw=v['remaining_tw'],
                        remaining_wr=v['remaining_wr'],
                        tail_method=v['tail_method']
                        )
                else:
                    dm.setup_constr_wr(
                        water_right_id=wr_id, wr=wr_args['wr'],
                        field_id_list=wr_args['field_id_list'],
                        time_window=wr_args['time_window'],
                        remaining_tw=wr_args['remaining_tw'],
                        remaining_wr=wr_args['remaining_wr'],
                        tail_method=wr_args['tail_method']
                        )

        dm.setup_constr_finance()
        dm.setup_obj(alpha_dict=dm_args['alphas'])
        dm.finish_setup(display_summary=dm_args['display_summary'])
        dm.solve(
            keep_gp_model=dm_args['keep_gp_model'],
            keep_gp_output=dm_args['keep_gp_output'],
            display_report=dm_args['display_report']
            )
        dm_sols = dm.sols
        dm.depose_gp_env()  # Release memory
        
        # try:
        #     #dm_sols = self.dm_sols
        #     self.gp_status = dm_sols['gp_status']
        #     self.gp_MIPGap = dm_sols['gp_MIPGap']
        #     self.gp_report = dm_sols['gp_report']
        # except:
        #     pass
        
        return dm_sols

    def make_dm_deliberation(self):
        """
        Make decision under the "Deliberation" CONSUMAT state.
    
        Returns
        -------
        None
    
        Notes
        -----
        This method updates the `dm_sols` attribute by calling the `make_dm` method
        with the current state set to "Deliberation".
        """
        self.dm_sols = self.make_dm(state="Deliberation", dm_sols=self.dm_sols)

    def make_dm_repetition(self):
        """
        Make decision under the "Repetition" CONSUMAT state.
    
        Returns
        -------
        None
    
        Notes
        -----
        This method updates the `dm_sols` attribute by calling the `make_dm` method
        with the current state set to "Repetition".
        """
        self.dm_sols = self.make_dm(state="Repetition", dm_sols=self.dm_sols)

    def make_dm_social_comparison(self):
        """
        Make decision under the "Social comparison" CONSUMAT state.
    
        Returns
        -------
        None
    
        Notes
        -----
        This method performs several key steps:
        1. Evaluates comparable decision-making solutions from agents in the network.
        2. Selects the agent with the best objective value.
        3. Compares the agent's original choice with the selected agent's choice.
        4. Updates the `dm_sols` attribute based on the comparison.
    
        The method assumes that `farmer_ids_in_network` and `farmers_in_network` are already
        initialized and populated.
        """
        farmer_ids_in_network = self.farmer_ids_in_network
        farmers_in_network = self.farmers_in_network
        # Evaluate comparable
        dm_sols_list = []
        for farmer_id in farmer_ids_in_network:
            # !!! Here we assume no. fields, n_c and split are the same across agents
            # Keep this for now.
            self.dm_sols_neighbor=farmers_in_network[farmer_id].dm_sols
            dm_sols = self.make_dm(
                state="Social comparison",
                dm_sols=self.dm_sols,
                dm_sols_neighbor=self.dm_sols_neighbor
                )
            dm_sols_list.append(dm_sols)
        objs = [s['obj'] for s in dm_sols_list]
        selected_agt_obj = max(objs)
        select_agt_index = objs.index(selected_agt_obj)
        self.selected_farmer_id_in_network = farmer_ids_in_network[select_agt_index]

        # Agent's original choice
        self.make_dm_repetition()
        dm_sols = self.dm_sols
        if dm_sols['obj'] >= selected_agt_obj:
            self.dm_sols = dm_sols
        else:
            self.dm_sols = dm_sols_list[select_agt_index]

    def make_dm_imitation(self):
        """
        Make decision under the "Imitation" CONSUMAT state.
    
        Returns
        -------
        None
    
        Notes
        -----
        This method performs the following key steps:
        1. Selects an agent from the network for imitation.
        2. Updates the `dm_sols` attribute by calling the `make_dm` method
           with the current state set to "Imitation" and using the selected agent's solutions.
    
        The method assumes that `farmer_ids_in_network` and `farmers_in_network` are already
        initialized and populated.
        """
        selected_farmer_id_in_network = self.selected_farmer_id_in_network
        if selected_farmer_id_in_network is None:
            try:    # if rngen is given in the model
                selected_farmer_id_in_network = self.rngen.choice(self.farmer_ids_in_network)
            except:
                selected_farmer_id_in_network = np.random.choice(self.farmer_ids_in_network)

        farmers_in_network = self.farmers_in_network
        self.dm_sols_neighbor=farmers_in_network[selected_farmer_id_in_network].dm_sols
        
        dm_sols = self.make_dm(
            state="Imitation",
            dm_sols=self.dm_sols,
            dm_sols_neighbor=self.dm_sols_neighbor
            )
        self.dm_sols = dm_sols

